plugins{
    id "java"
}

group = "stealthpath"
version = "4.3.0"

repositories{
    mavenCentral()
    maven{ url "https://jitpack.io" }
}

dependencies{
    // Prefer building against a local Mindustry source checkout (as an included subproject).
    if(rootProject.findProject(":core") != null){
        compileOnly project(":core")
    }else{
        // Standalone build: fetch Mindustry core from JitPack.
        def mindustryVersion = (findProperty("mindustryVersion") ?: "v154.3").toString()
        compileOnly "com.github.Anuken.MindustryJitpack:core:$mindustryVersion"
    }
}

tasks.withType(JavaCompile).configureEach{
    options.encoding = "UTF-8"
}

jar{
    // A Mindustry Java mod is a zip/jar archive with classes + resources.
    // Use .zip extension for distribution.
    archiveFileName = "${project.name}.zip"
}

// Keep a copy at the repo root for easy install.
tasks.register("copyZipToRoot", Copy){
    // Root contains Gradle locks; disable state tracking to avoid snapshot failures.
    doNotTrackState("Copies into root directory which may contain unreadable Gradle lock files.")
    dependsOn tasks.named("jar")
    from(tasks.named("jar").flatMap{ it.archiveFile })
    // "root" here means the directory alongside Mindustry-main/Mindustry-master.
    into(rootDir.parentFile)
}

// Keep a copy in dist/ for GitHub releases.
tasks.register("copyZipToDist", Copy){
    dependsOn tasks.named("jar")
    mustRunAfter tasks.named("copyZipToRoot")
    from(tasks.named("jar").flatMap{ it.archiveFile })
    into(new File(project.projectDir, "dist"))
    rename{ _ -> "${project.name}.zip" }
    doNotTrackState("Copying into dist is a convenience step; state tracking is unnecessary here.")
}

// Keep a copy in workspace root "构建/" for archiving.
tasks.register("copyZipToBuildFolder", Copy){
    dependsOn tasks.named("jar")
    mustRunAfter tasks.named("copyZipToDist")
    from(tasks.named("jar").flatMap{ it.archiveFile })
    into(new File(rootDir.parentFile, "构建"))
    rename{ _ -> "${project.name}-${project.version}.zip" }
    doNotTrackState("Copying into workspace build folder is a convenience step; state tracking is unnecessary here.")
}

tasks.named("jar").configure{
    finalizedBy tasks.named("copyZipToRoot")
    finalizedBy tasks.named("copyZipToDist")
    finalizedBy tasks.named("copyZipToBuildFolder")
}

def isWindows = System.getProperty("os.name").toLowerCase(Locale.ROOT).contains("windows")

def findD8 = {
    def explicit = System.getenv("D8_PATH")
    if(explicit){
        def f = new File(explicit)
        if(f.exists()) return f
    }

    def sdkRoot = System.getenv("ANDROID_SDK_ROOT") ?: System.getenv("ANDROID_HOME")
    if(sdkRoot){
        def buildToolsDir = new File(sdkRoot, "build-tools")
        if(buildToolsDir.isDirectory()){
            def toolName = isWindows ? "d8.bat" : "d8"
            def candidates = (buildToolsDir.listFiles() ?: [])
                .findAll{ it.isDirectory() }
                .sort{ a, b -> b.name <=> a.name }

            for(def dir : candidates){
                def exe = new File(dir, toolName)
                if(exe.exists()) return exe
            }
        }
    }

    if(isWindows){
        def workspaceRoot = rootDir.parentFile
        def matches = (workspaceRoot.listFiles() ?: [])
            .findAll{ it.isDirectory() && it.name.startsWith("commandlinetools-win-") }
            .sort{ a, b -> b.name <=> a.name }

        for(def dir : matches){
            def exe = new File(dir, "cmdline-tools/bin/d8.bat")
            if(exe.exists()) return exe
        }
    }

    return null
}

def androidDexOutDir = layout.buildDirectory.dir("d8").get().asFile

tasks.register("d8InputJar", Jar){
    group = "build"
    description = "Builds a jar used only as input for D8 (no dist side effects)."
    dependsOn tasks.named("classes")
    archiveFileName = "${project.name}-d8-input.jar"
    destinationDirectory = layout.buildDirectory.dir("d8-input")
    from(sourceSets.main.output)
}

// Gradle 8+ validation: make the ordering explicit when both tasks are in the graph.
tasks.named("d8InputJar").configure{
    mustRunAfter tasks.named("copyZipToRoot")
}

tasks.register("dexAndroid", Exec){
    group = "build"
    description = "Compiles Java bytecode into classes.dex for Mindustry Android mod loading."
    dependsOn tasks.named("d8InputJar")

    doFirst{
        def d8 = findD8()
        if(d8 == null){
            throw new GradleException("D8 not found. Set ANDROID_SDK_ROOT/ANDROID_HOME or D8_PATH (or keep commandlinetools-win-* in workspace root on Windows).")
        }
        delete(androidDexOutDir)
        androidDexOutDir.mkdirs()

        def programZip = tasks.named("d8InputJar").get().archiveFile.get().asFile

        commandLine d8.absolutePath
        args "--min-api", "14", "--release", "--output", androidDexOutDir.absolutePath
        args programZip.absolutePath
    }
}

tasks.register("jarAndroid", Jar){
    group = "build"
    description = "Packages an Android-compatible mod JAR containing classes.dex."
    dependsOn tasks.named("dexAndroid")

    archiveFileName = "${project.name}-android.jar"
    destinationDirectory = layout.buildDirectory.dir("libs")

    from(androidDexOutDir){
        include "classes.dex"
    }
    from(sourceSets.main.output.resourcesDir)
}

tasks.register("copyAndroidJarToDist", Copy){
    dependsOn(tasks.named("jarAndroid"))
    from(tasks.named("jarAndroid").flatMap{ it.archiveFile })
    into(new File(project.projectDir, "dist"))
    rename{ _ -> "${project.name}-android.jar" }
    doNotTrackState("Copying into dist is a convenience step; state tracking is unnecessary here.")
}
